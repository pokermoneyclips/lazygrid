@import 'variables';
@import 'queries';

// !-- all grid mixins WITH PREDEFINED CLASSES will be found below in a cleanup effort to keep things neat and organized --
// produces equally sized grid items
@mixin grid_width() {
	$grid_width_em: (($page_width / $grid) - ($gutter_px * 2))/$font_px; //math for grid width
	.grid_#{$grid} {
			width: $grid_width_em +0em;
			margin: 0 $gutter_em +0em;
			float:left;
			@content;
	}			
}

// $combine_span is the number of grid items you'd like to conjoin together
@mixin column_combine ($combine_span) {
	$grid_width_em: ((($page_width / $grid) * $combine_span) - ($gutters_px))/$font_px; //math for grid width
	.gridspan_#{$grid}_span#{$combine_span} {
		min-width: $grid_width_em +0em;	
		max-width: $grid_width_em +0em;	
		margin: 0 $gutter_em +0em;
		float:left;						
		@content;
	}
}

// Adaptive Media Queries
// Min and Max
@mixin mediamax_adapt ($combine_span, $min_width, $max_width) {
	$grid_width_em: ((($min_width / $grid) * $combine_span) - ($gutters_px))/$font_px; //math for grid width
	@include media_query_gen($min_width, $max_width) {
		.gridspan_#{$grid}_span#{$combine_span} {
			width: $grid_width_em +0em;	
			margin: 0 $gutter_em +0em;
			float:left;						
			@content;
			}
	}
}

// Min only
@mixin media_adapt ($combine_span, $min_width) {
	$grid_width_em: ((($min_width / $grid) * $combine_span) - ($gutters_px))/$font_px; //math for grid width
	@include media_query_minonly($min_width) {
		.gridspan_#{$grid}_span#{$combine_span} {
			width: $grid_width_em +0em;	
			margin: 0 $gutter_em +0em;
			float:left;						
			@content;
			}
	}
}


// for creating media queries on the fly for overriding widths at various breakpoints
// theres alot going on here so lets break it down
// we want to check and see if our grid widths would be correct given the window size, else well make them full span the window
// being that these are min and max values here were going to be setting our display type to table cell so our elements will expand correctly
// our margins will then be applied to the container for this particular grid using border-collapse and border-spacing
// yes this sucks as its using table css and wont degrade well but hey I refused to use percentage values and wanted this to be a variable width
@mixin media_column ($combine_span, $min_width, $max_width) {
	$if_grid_width: ((($page_width / $grid) * $combine_span) - ($gutters_px)); // comparison operator for if statements
	$grid_width_em: $if_grid_width/$font_px; // convert from pixels to em
	// min and max in pixels
	$if_min_width: ((($min_width / $grid) * $combine_span) - ($gutters_px)); // comparison operator for min
	$if_max_width: ((($max_width / $grid) * $combine_span) - ($gutters_px)); // comparison operator for max
	//min and max in ems
	$min_grid_width_em: $if_min_width/$font_px;
	$max_grid_width_em: $if_max_width/$font_px;
	
	@include media_query_gen($min_width, $max_width) {
			.gridspan_#{$grid}_span#{$combine_span} {
				@if($if_min_width >= $if_grid_width) {
					min-width: $grid_width_em +0em;
				}
				@else {
					min-width: $min_grid_width_em +0em;
				}
				@if($if_max_width >= $if_grid_width) {
					max-width: $grid_width_em +0em;
				}
				@else {
					max-width: $max_grid_width_em +0em;
				}
				margin:0;
				display:table-cell;
				@content;
			}
		}
}

// for creating media queries on the fly for overriding widths at various breakpoints
// this one assumes you have a set width for your container so elements will have a min and max of their grid element and will not grow larger than the page itself
@mixin media_minonly ($combine_span, $min_width) {
	$if_grid_width: ((($page_width / $grid) * $combine_span) - ($gutters_px)); // comparison operator for if statements
	$grid_width_em: $if_grid_width/$font_px; // convert from pixels to em
	// min in pixels
	$if_min_width: ((($min_width / $grid) * $combine_span) - ($gutters_px)); // comparison operator for min
	//min in ems
	$min_grid_width_em: $if_min_width/$font_px;
	
	@include media_query_minonly($min_width) {
			.gridspan_#{$grid}_span#{$combine_span} {
				@if($if_min_width >= $if_grid_width) {
					min-width: $grid_width_em +0em;
					max-width: $grid_width_em +0em;					
				}
				@else {
					min-width: $min_grid_width_em +0em;
					max-width: $min_grid_width_em +0em;
				}
				margin: 0 $gutter_em +0em;
				float:left;
				@content;
			}
		}
}

// create 100% fluid grids for smaller displayers
@mixin mobile_grid ($combine_span) {
	.gridspan_#{$grid}_span#{$combine_span} {	
		margin: 0 $gutter_em +0em;
		@content;
	}
}



// create 100% fluid grids for smaller displayers
@mixin mobile_nesting ($combine_span, $nest_span) {
		.nest_span#{$combine_span}_ns#{$nest_span} {
			margin: 0 $gutter_em +0em;
			@content;
			
			&:first-of-type { // remove margin left from first element nested as its parent already has this
				margin-left:0;
			}
			
			&:last-of-type { // remove margin right from last element nested as its parent already has this
				margin-right:0;
			}
		}
}

//pushing and pulling elements
@mixin combine_pushpull($combine_spread, $pushpull: push) {
	$grid_push_width_em: ((($page_width / $grid) * $combine_spread) - ($gutters_px))/$font_px; //math for grid width
	$push_width_em: $page_width - $grid_push_width_em;
	
	@if $pushpull == push {
	margin-left: $push_width_em +0em;
	}
	@if $pushpull == pull {
	margin-left: $grid_push_width_em +0em;
	}
	margin-right: -100%;
}
